#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "LED.h"
#include "Key.h"
#include "Buzzer.h"
#include "LightSensor.h"
#include "OLED.h"
#include "Serial.h"

uint8_t KeyNum;
/*
串口通信

串口协议硬件部分：协议规定一个设备使用TX发送高低电平，另一个设备使用RX接受高低电平，

线路中使用TTL，因为STM32是3.3v的器件，所以线路对地是3.3v就说明发送了逻辑1，对地是0v就说明发送了逻辑0

串口协议软件部分：串口中每个字节都装载在一个数据帧内，

串口使用异步通信，所以需要双方设备约定好通信速率（波特率 码元/s、比特率bps bit/s），
二进制调制下，一个码元就是一个bit，此时波特率=比特率

起始位：串口的空闲状态（没有数据传输时）引脚置高电平，需要数据传输时必须要先发送一个起始位，
起始位必须是低电平，来打破空闲状态，并且告诉另一个设备我要开始发送数据了

停止位：在一个字节数据发送完后，必须要有一个停止位，用于数据帧间隔，固定为高电平，
同时也为下一次起始位的下降沿做准备，停止位的长度是可以配置的

数据位：数据帧的有效载荷，地位先行，从右到左

校验位：用于数据帧间隔，固定位高电平，无校验、奇校验、偶校验，发送方会保证1的个数为奇数或偶数，
而在校验位补1或0，接收方会验证数据位和校验位，如果1的个数还是原来的奇数或偶数，就认为数据没出错，
如果在传输中因干扰，有一位由1变成0了或者由0变成1了，那接收方就认为传输出错，就可以选择丢弃或者重新传。
（如果有两位数据同时出错，奇偶校验就检验不出来了，可以了解一下CRC校验）

USART 通用同步异步收发器

USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，
从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里

自带波特率发生器4.5Mbits/s，是用来配置波特率的，其实就是一个分频器（9600、115200）

可配置数据位长度8/9 、停止位长度0.5/1/1.5/2

可选校验位无校验、奇校验、偶校验

DR数据寄存器，发送数据和接受数据共用一个DR寄存器，
当读取DR寄存器的值时，功能为接受数据，当写入DR寄存器的值时，功能为发送数据

波特率=fpclk / (16 * DIV)
*/
int main(void)
{
	//uint8_t MyArray[] = {0x43, 0x44, 0x45, 0x46};
	
	char String[100];
	// 本节主要是利用USB转串口模块和电脑进行通信
	// 可以通过发送数据发送给其他支持串口的模块
	
	OLED_Init();
	Serial_Init();
	//Serial_SendByte(0x41);
	//Serial_SendByte('B');
	
	
	
	//Serial_SendArray(MyArray, 4);
	// 一个叫回车，一个叫换行，在机械打字机的年代，回车是把打印头移到本行首位置，换行是将打印头下移一行
	// '\n'是换行，后者使光标下移一格，（line feed）
	// '\r'是回车，前者使光标到行首，（carriage return）
	//Serial_SendString("  HelloWorld!\r\n"); // 这里需要用\r\n两个转义字符才能实现换行
	//Serial_SendNumber(12345, 5);
	
	/*
		需要重定向printf
		这里已经在Serial.c文件中进行重写fputc函数，也就是重定向了printf
		只适用于单个串口需要printf方法
	*/
	//printf("Num = %d\r\n", 666); 
	
	
	/*
		sprintf可以把一个格式化字符输出到一个字符串里
		不涉及重定向的东西，所有串口都可以使用sprintf打印
		在Serial.c文件中对下面这些操作进行了封装，用到了 C语言可变参数列表的知识点
		
		可以适用于多个串口需要printf方法
	*/
	//sprintf(String, "Num = %d\r\n", 676);
	//Serial_SendString(String);
	
	/*
		将上个例子封装后的函数
	*/
	//Serial_Printf("Num = %d\r\n", 688);
	
	
	// 打印中文需要 串口助手和编译器采用同一种中文编码格式，这里都是GBK，并且在编译器选项C/C++中输入--no-multibyte-chars
	//Serial_Printf("你好，世界");
	
	while(1)
	{

	}
	
	//Buzzer_OFF();
}

